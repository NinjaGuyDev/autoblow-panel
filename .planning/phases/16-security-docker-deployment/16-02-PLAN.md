---
phase: 16-security-docker-deployment
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - docker/Dockerfile
  - docker/Dockerfile.backend
  - docker/docker-compose.yml
  - docker/nginx.conf
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "docker compose up --build starts both frontend (nginx) and backend (Express) services"
    - "Frontend served by nginx on port 80 with security headers and CSP"
    - "Backend accessible only on localhost:3001 with SQLite data persisted via Docker volume"
    - "SPA routing works (refreshing /library does not 404)"
    - "API requests from frontend proxy through nginx to backend"
    - "Docker image size is under 200MB for frontend, under 300MB for backend"
  artifacts:
    - path: "docker/Dockerfile"
      provides: "Multi-stage frontend build (Vite build -> nginx Alpine)"
      contains: "FROM nginx:alpine"
    - path: "docker/Dockerfile.backend"
      provides: "Backend build (TypeScript compile -> Node Alpine runtime)"
      contains: "FROM node"
    - path: "docker/docker-compose.yml"
      provides: "Service orchestration with volume persistence and health checks"
      contains: "sqlite-data"
    - path: "docker/nginx.conf"
      provides: "nginx config with SPA fallback, security headers, API proxy, gzip"
      contains: "try_files"
    - path: ".dockerignore"
      provides: "Excludes node_modules, .git, dist, .planning from build context"
      contains: "node_modules"
  key_links:
    - from: "docker/docker-compose.yml"
      to: "docker/Dockerfile"
      via: "build context reference"
      pattern: "dockerfile.*Dockerfile"
    - from: "docker/docker-compose.yml"
      to: "docker/Dockerfile.backend"
      via: "backend service build"
      pattern: "Dockerfile\\.backend"
    - from: "docker/nginx.conf"
      to: "backend service"
      via: "proxy_pass to Express"
      pattern: "proxy_pass.*3001"
    - from: "docker/docker-compose.yml"
      to: "sqlite-data volume"
      via: "volume mount for /app/data"
      pattern: "sqlite-data:/app/data"
---

<objective>
Create Docker deployment infrastructure: multi-stage Dockerfiles for frontend (nginx) and backend (Express), docker-compose orchestration with volume persistence for SQLite, and nginx configuration with security headers, SPA fallback, gzip compression, and API reverse proxy.

Purpose: Enable one-command production deployment via `docker compose up --build` with all security headers enforced at the nginx layer, SQLite data persisted across container restarts, and the full application stack running in isolated containers.

Output: Complete Docker deployment setup in `docker/` directory plus `.dockerignore`.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-security-docker-deployment/16-RESEARCH.md
@.planning/phases/16-security-docker-deployment/16-01-SUMMARY.md
@server/index.ts
@package.json
@vite.config.ts
@tsconfig.json
@tsconfig.server.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker Configuration Files</name>
  <files>docker/Dockerfile, docker/Dockerfile.backend, docker/docker-compose.yml, docker/nginx.conf, .dockerignore</files>
  <action>
1. Create `.dockerignore` at project root:
   ```
   node_modules/
   dist/
   build/
   .git/
   .planning/
   .env*
   !.env.example
   *.md
   coverage/
   __tests__/
   *.test.ts
   *.spec.ts
   .vscode/
   .idea/
   .DS_Store
   npm-debug.log*
   data/
   media/
   ```
   Note: `data/` and `media/` excluded because they're runtime data, not build artifacts. `package-lock.json` should NOT be excluded (needed for `npm ci`).

2. Create `docker/Dockerfile` (frontend multi-stage build):
   - **Stage 1 (build):** `FROM node:20-alpine AS builder`
     - `WORKDIR /app`
     - `COPY package.json package-lock.json ./`
     - `RUN npm ci` (full install including devDependencies for Vite build)
     - `COPY tsconfig.json tsconfig.app.json tsconfig.node.json vite.config.ts index.html ./`
     - `COPY src/ ./src/`
     - `COPY public/ ./public/` (if exists, use `COPY public/ ./public/ 2>/dev/null || true` pattern -- actually just check if public/ exists first; if not, skip this line)
     - `COPY server/types/ ./server/types/` (needed because `src/lib/apiClient.ts` imports from `../../server/types/shared`)
     - `RUN npm run build`
   - **Stage 2 (runtime):** `FROM nginx:1.25-alpine`
     - `COPY docker/nginx.conf /etc/nginx/nginx.conf`
     - `COPY --from=builder /app/dist /usr/share/nginx/html`
     - `EXPOSE 80`
     - `CMD ["nginx", "-g", "daemon off;"]`
   - IMPORTANT: The frontend build needs `server/types/` because apiClient.ts imports shared types from there. Copy only `server/types/` not the entire `server/` directory.

3. Create `docker/Dockerfile.backend`:
   - **Stage 1 (build):** `FROM node:20-alpine AS builder`
     - `WORKDIR /app`
     - `COPY package.json package-lock.json ./`
     - `RUN npm ci`
     - `COPY tsconfig.server.json ./`
     - `COPY server/ ./server/`
     - The backend is run via `tsx` in dev, but for production we need compiled JS. Add a build step:
       - `RUN npx tsc -p tsconfig.server.json --outDir dist/server --declaration false`
       - BUT tsconfig.server.json has `noEmit: true`. So instead: `RUN npx tsc --project tsconfig.server.json --outDir dist/server --noEmit false`
   - **Stage 2 (runtime):** `FROM node:20-alpine`
     - `WORKDIR /app`
     - `COPY --from=builder /app/dist/server ./server/`
     - `COPY package.json package-lock.json ./`
     - `RUN npm ci --omit=dev` (production only - installs express, better-sqlite3, cors, etc.)
     - `RUN mkdir -p /app/data /app/media` (ensure directories exist for volumes)
     - `ENV NODE_ENV=production`
     - `ENV DB_PATH=/app/data/autoblow.db`
     - `ENV MEDIA_DIR=/app/media`
     - `EXPOSE 3001`
     - `CMD ["node", "server/index.js"]`
   - Note: `better-sqlite3` needs to be compiled for the Alpine target. `npm ci` in the Alpine container handles this via prebuilt binaries or node-gyp. If node-gyp is needed, add `RUN apk add --no-cache python3 make g++` before `npm ci` in the runtime stage (only if build fails without it).

4. Create `docker/nginx.conf`:
   - `worker_processes auto;`
   - `events { worker_connections 1024; }`
   - `http` block:
     - `include /etc/nginx/mime.types;`
     - `default_type application/octet-stream;`
     - Performance: `sendfile on; tcp_nopush on; tcp_nodelay on;`
     - Gzip: `gzip on; gzip_vary on; gzip_comp_level 6; gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;`
     - Security headers (global):
       - `add_header X-Frame-Options "SAMEORIGIN" always;`
       - `add_header X-Content-Type-Options "nosniff" always;`
       - `add_header Referrer-Policy "strict-origin-when-cross-origin" always;`
       - CSP matching helmet config: `add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com https://*.pornhub.com https://*.xvideos.com; img-src 'self' data: https:; connect-src 'self';" always;`
       - Do NOT add HSTS header (per research pitfall #9 -- this is a localhost app, HSTS would lock out HTTP and cause confusion).
       - Do NOT add X-XSS-Protection (deprecated in modern browsers per research).
     - Server block (port 80):
       - `root /usr/share/nginx/html;`
       - `index index.html;`
       - Static asset caching: `location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ { expires 1y; add_header Cache-Control "public, immutable"; }`
       - SPA fallback: `location / { try_files $uri $uri/ /index.html; }` (per research pitfall #8)
       - API proxy: `location /api { proxy_pass http://backend:3001; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }` (use `backend` hostname from docker-compose service name)
       - Health proxy: `location /health { proxy_pass http://backend:3001; }` (allows external health checks through nginx)

5. Create `docker/docker-compose.yml`:
   - Use `version: '3.8'` (or omit version for modern Compose).
   - **frontend service:**
     - `build: { context: .., dockerfile: docker/Dockerfile }`
     - `ports: ["80:80"]`
     - `depends_on: { backend: { condition: service_healthy } }`
     - `networks: [app-network]`
   - **backend service:**
     - `build: { context: .., dockerfile: docker/Dockerfile.backend }`
     - `ports: ["127.0.0.1:3001:3001"]` (bind to localhost only -- external access goes through nginx)
     - `volumes: [sqlite-data:/app/data, media-data:/app/media]` (persist both SQLite and media files)
     - `environment: { NODE_ENV: production }`
     - `healthcheck: { test: ["CMD", "node", "-e", "require('http').get('http://localhost:3001/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"], interval: 30s, timeout: 10s, retries: 3, start_period: 40s }`
     - `networks: [app-network]`
   - **volumes:** `sqlite-data: { driver: local }`, `media-data: { driver: local }`
   - **networks:** `app-network: { driver: bridge }`
  </action>
  <verify>
- All 5 files exist: `.dockerignore`, `docker/Dockerfile`, `docker/Dockerfile.backend`, `docker/docker-compose.yml`, `docker/nginx.conf`.
- `docker compose -f docker/docker-compose.yml config` validates without errors (if Docker is available).
- Dockerfile syntax is valid (no obvious COPY/RUN errors).
- nginx.conf includes `try_files` for SPA fallback.
- nginx.conf includes `proxy_pass` for API routing.
- docker-compose.yml includes volume definitions for `sqlite-data` and `media-data`.
- `.dockerignore` excludes `node_modules/`, `.git/`, `data/`, `media/`.
  </verify>
  <done>Complete Docker deployment infrastructure: multi-stage frontend (nginx), backend (Node Alpine), docker-compose with health checks, volume persistence, and nginx with security headers + SPA routing + API proxy. Deployable via `docker compose -f docker/docker-compose.yml up --build`.</done>
</task>

</tasks>

<verification>
1. `docker compose -f docker/docker-compose.yml config` validates successfully
2. `.dockerignore` excludes build context bloat (node_modules, .git, data, media)
3. nginx.conf has SPA fallback (`try_files $uri $uri/ /index.html`)
4. nginx.conf has CSP header matching Phase 16 requirements (frame-src for YouTube, Vimeo, adult platforms)
5. nginx.conf proxies `/api` to backend service
6. docker-compose.yml persists SQLite data via named volume
7. Backend port bound to localhost only in docker-compose (`127.0.0.1:3001:3001`)
8. Health check configured for backend service
</verification>

<success_criteria>
- `docker compose -f docker/docker-compose.yml up --build` would start full application stack
- Frontend served by nginx with security headers on port 80
- Backend runs Node.js with production environment on port 3001 (localhost only)
- SQLite database persists across container restarts via Docker volume
- Media files persist via separate Docker volume
- nginx proxies API requests to backend container
- SPA routes work on page refresh (no 404s)
- Docker images use multi-stage builds with Alpine base (small image size)
</success_criteria>

<output>
After completion, create `.planning/phases/16-security-docker-deployment/16-02-SUMMARY.md`
</output>
