---
phase: 16-security-docker-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/middleware/security.ts
  - server/middleware/localhost-only.ts
  - server/routes/health.ts
  - server/index.ts
  - src/lib/tokenEncryption.ts
  - src/hooks/useDeviceConnection.ts
autonomous: true

must_haves:
  truths:
    - "Backend rejects requests from non-localhost IPs with 403"
    - "Backend sets CSP headers allowing YouTube, Vimeo, and adult platform iframes"
    - "Backend sets standard security headers (X-Content-Type-Options, X-Frame-Options, Referrer-Policy)"
    - "Device token is encrypted in localStorage using AES-GCM, not stored as plaintext"
    - "Health endpoint returns 200 with database connectivity check"
    - "CSP does not break Vite HMR in development (only applied in production)"
  artifacts:
    - path: "server/middleware/security.ts"
      provides: "Helmet security middleware with CSP configuration"
      contains: "helmet"
    - path: "server/middleware/localhost-only.ts"
      provides: "IP validation middleware for localhost-only access"
      contains: "ALLOWED_IPS"
    - path: "server/routes/health.ts"
      provides: "Health check endpoint with DB verification"
      exports: ["default"]
    - path: "src/lib/tokenEncryption.ts"
      provides: "Web Crypto AES-GCM encrypt/decrypt for device tokens"
      exports: ["encryptToken", "decryptToken"]
  key_links:
    - from: "server/index.ts"
      to: "server/middleware/security.ts"
      via: "app.use(helmetMiddleware)"
      pattern: "app\\.use.*helmet"
    - from: "server/index.ts"
      to: "server/middleware/localhost-only.ts"
      via: "app.use(localhostOnly)"
      pattern: "app\\.use.*localhostOnly"
    - from: "server/index.ts"
      to: "server/routes/health.ts"
      via: "app.use('/health', healthRouter)"
      pattern: "health"
    - from: "src/hooks/useDeviceConnection.ts"
      to: "src/lib/tokenEncryption.ts"
      via: "encryptToken/decryptToken calls"
      pattern: "encryptToken|decryptToken"
---

<objective>
Add security hardening to the Express backend (localhost-only validation, helmet.js security headers with CSP for iframe embeds, health endpoint) and implement Web Crypto API token encryption for the device token stored in localStorage.

Purpose: Protect the backend from non-local access, enforce browser security policies for iframe embeds (YouTube, Vimeo, adult sites), and encrypt sensitive device tokens at rest to prevent XSS-based token theft.

Output: Security middleware applied to Express server, health check endpoint, encrypted token storage in frontend.
</objective>

<execution_context>
@/home/esfisher/.claude/get-shit-done/workflows/execute-plan.md
@/home/esfisher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-security-docker-deployment/16-RESEARCH.md
@server/index.ts
@server/middleware/errorHandler.ts
@server/db/connection.ts
@src/hooks/useDeviceConnection.ts
@src/lib/apiClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend Security Middleware + Health Endpoint</name>
  <files>server/middleware/security.ts, server/middleware/localhost-only.ts, server/routes/health.ts, server/index.ts</files>
  <action>
1. Install helmet: `npm install helmet` and `npm install -D @types/helmet` (if types not bundled).

2. Create `server/middleware/localhost-only.ts`:
   - Export `localhostOnly` middleware function accepting (req, res, next).
   - Define ALLOWED_IPS array: `['127.0.0.1', '::1', '::ffff:127.0.0.1']`.
   - Read client IP from `req.ip || req.socket.remoteAddress`.
   - If IP not in allowed list, return 403 JSON: `{ error: 'Access denied - localhost only' }` and log warning to console.
   - Otherwise call `next()`.

3. Create `server/middleware/security.ts`:
   - Import helmet.
   - Export a function `createSecurityMiddleware()` that returns the helmet middleware configured with:
     - `contentSecurityPolicy.directives`:
       - `defaultSrc: ["'self'"]`
       - `scriptSrc: ["'self'"]`
       - `styleSrc: ["'self'", "'unsafe-inline'"]` (Tailwind requires unsafe-inline)
       - `frameSrc: ["https://www.youtube.com", "https://www.youtube-nocookie.com", "https://player.vimeo.com", "https://*.pornhub.com", "https://*.xvideos.com"]`
       - `imgSrc: ["'self'", "data:", "https:"]` (thumbnails from embed platforms)
       - `connectSrc: ["'self'"]`
     - Do NOT set HSTS (handled by nginx in production; short max-age causes confusion in dev).
     - Keep other helmet defaults (X-Content-Type-Options, X-Frame-Options, etc.).
   - Export the CSP frame-src list as a constant `ALLOWED_FRAME_SOURCES` for reuse in nginx config documentation.

4. Create `server/routes/health.ts`:
   - Export a Router with GET `/` route.
   - Return JSON: `{ status: 'ok', timestamp: ISO string, uptime: process.uptime(), checks: { database: 'ok'|'error' } }`.
   - Test DB by running `db.prepare('SELECT 1').get()` inside try/catch.
   - On DB error, return 503 with `status: 'error'`.
   - Import db from `../db/connection.js`.

5. Update `server/index.ts`:
   - Import `localhostOnly` from `./middleware/localhost-only.js`.
   - Import `createSecurityMiddleware` from `./middleware/security.js`.
   - Import health router from `./routes/health.js`.
   - Apply `localhostOnly` BEFORE cors: `app.use(localhostOnly)`.
   - Apply security middleware only in production: `if (process.env.NODE_ENV === 'production') app.use(createSecurityMiddleware())`. This prevents CSP from breaking Vite HMR in development (per research pitfall #2).
   - Mount health router: `app.use('/health', healthRouter)`.
   - Keep existing cors, json parser, routes, and error handler in same order.
  </action>
  <verify>
- `npm run dev:backend` starts without errors.
- `curl http://127.0.0.1:3001/health` returns `{"status":"ok","checks":{"database":"ok"}}`.
- `curl http://localhost:3001/health` returns 200 (not 403, since localhost resolves to allowed IP).
- Server logs show no security middleware CSP errors in dev mode (helmet not applied in dev).
  </verify>
  <done>Backend starts with localhost-only validation, health endpoint returns 200 with DB check, security headers configured for production mode only.</done>
</task>

<task type="auto">
  <name>Task 2: Web Crypto Token Encryption</name>
  <files>src/lib/tokenEncryption.ts, src/hooks/useDeviceConnection.ts</files>
  <action>
1. Create `src/lib/tokenEncryption.ts`:
   - Implement AES-GCM encryption using Web Crypto API with PBKDF2 key derivation.
   - Use a hardcoded app-level salt derivation password (combination of app name + version) since this is a local-only app with no user accounts. Per research open question #1: use device-ID-based approach (transparent to user). Since we don't have a device ID at encryption time, use a static app identifier: `'autoblow-panel-v1'`. This provides protection against generic XSS scrapers reading raw localStorage but is not meant to resist targeted attacks.
   - Constants: `SALT_KEY = 'autoblow-token-salt'`, `IV_KEY = 'autoblow-token-iv'`, `TOKEN_KEY = 'autoblow-device-token'`.
   - `deriveKey(password: string, salt: Uint8Array): Promise<CryptoKey>` - imports password as PBKDF2 raw key, derives AES-GCM 256-bit key with 100000 iterations, SHA-256 hash.
   - `encryptToken(token: string): Promise<void>` - generates new salt if none stored, generates fresh 12-byte IV every time (per research pitfall #6 - never reuse IV), encrypts token, stores ciphertext + IV + salt in localStorage as base64.
   - `decryptToken(): Promise<string | null>` - reads ciphertext/IV/salt from localStorage, derives key, decrypts. Returns null on failure (wrong key, corrupted data, or no stored token).
   - `clearEncryptedToken(): void` - removes all three localStorage keys.
   - Helper functions: `arrayBufferToBase64(buffer: ArrayBuffer): string` and `base64ToArrayBuffer(base64: string | null): ArrayBuffer | null`.
   - The password is internal (app-level constant), NOT user-facing. This is deliberate: the goal is encrypting at rest, not authenticating users.

2. Update `src/hooks/useDeviceConnection.ts`:
   - Import `encryptToken`, `decryptToken`, `clearEncryptedToken` from `@/lib/tokenEncryption`.
   - Change `savedToken` initialization: instead of synchronous `localStorage.getItem()`, initialize to empty string and load via `useEffect` that calls `decryptToken()` and sets `savedToken` on mount.
   - In `connect()` success path: replace `localStorage.setItem(DEVICE_TOKEN_KEY, token)` with `await encryptToken(token)`.
   - Keep `DEVICE_TOKEN_KEY` constant but only use it through the encryption module now.
   - Add backward compatibility: if `decryptToken()` returns null but raw `localStorage.getItem(DEVICE_TOKEN_KEY)` returns a non-base64-looking string (plaintext), treat it as a legacy unencrypted token, encrypt it, and use it. This handles the upgrade path from unencrypted to encrypted storage.
  </action>
  <verify>
- `npm run dev` starts without errors (both frontend and backend).
- In browser console: `localStorage.getItem('autoblow-device-token')` returns base64-encoded ciphertext (not plaintext) after entering and saving a device token.
- `localStorage.getItem('autoblow-token-iv')` and `localStorage.getItem('autoblow-token-salt')` are populated.
- Refreshing the page correctly decrypts and restores the saved token.
  </verify>
  <done>Device token stored encrypted in localStorage via AES-GCM. Existing plaintext tokens auto-migrated on first load. Fresh IV generated per encryption operation.</done>
</task>

</tasks>

<verification>
1. Backend starts and responds to health check: `curl http://127.0.0.1:3001/health` returns 200
2. Non-localhost requests rejected: simulate by checking middleware logic (unit-level)
3. CSP headers present in production mode: `NODE_ENV=production npm run dev:backend` then check response headers
4. Token in localStorage is encrypted (not readable plaintext)
5. `npm run build` succeeds without TypeScript errors
6. `npm run lint` passes
</verification>

<success_criteria>
- Backend rejects non-localhost requests with 403
- Helmet security headers applied in production mode
- CSP allows YouTube, Vimeo, and adult platform iframes via frame-src
- Health endpoint returns DB status
- Device token encrypted at rest in localStorage using AES-GCM
- Existing plaintext tokens auto-migrated to encrypted format
- No regressions: dev mode works normally, no CSP blocking Vite HMR
</success_criteria>

<output>
After completion, create `.planning/phases/16-security-docker-deployment/16-01-SUMMARY.md`
</output>
